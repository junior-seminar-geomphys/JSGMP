<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>S√©minaires pass√©s | S√©minaire Junior en G√©om√©trie et Physique Math√©matique</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Garamond', 'Georgia', serif;
            line-height: 1.8;
            color: #2c2c2c;
            background: #f5f5f0;
            font-size: 18px;
        }

        .container {
            max-width: 100%;
            margin: 0 auto;
            background: white;
        }

        header {
            background: linear-gradient(135deg, #00703c 0%, #1a4d2e 100%);
            color: white;
            padding: 2.5rem 2rem;
            text-align: center;
            position: relative;
            overflow: hidden;
            border-bottom: 5px solid #c9a961;
            min-height: 350px;
        }

        #wormholeCanvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            opacity: 0.5;
        }

        .university-name {
            font-size: 1.15rem;
            margin-bottom: 0.8rem;
            opacity: 0.95;
            position: relative;
            z-index: 1;
            letter-spacing: 0.5px;
        }

        header h1 {
            font-size: 2.8rem;
            font-weight: 400;
            margin: 1rem 0;
            position: relative;
            z-index: 1;
            line-height: 1.3;
            background: linear-gradient(
                90deg,
                #ffffff 0%,
                #ffd700 25%,
                #ff96ff 50%,
                #8a2be2 75%,
                #ffffff 100%
            );
            background-size: 200% auto;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            animation: shimmer 4s linear infinite;
            text-shadow: 0 0 20px rgba(255, 215, 0, 0.3);
        }

        @keyframes shimmer {
            0% { background-position: 0% center; }
            100% { background-position: 200% center; }
        }

        .lang-switch {
            margin-top: 1.5rem;
            display: flex;
            gap: 1rem;
            justify-content: center;
            position: relative;
            z-index: 1;
        }

        .lang-switch button {
            background: rgba(255,255,255,0.2);
            border: 2px solid rgba(255,255,255,0.5);
            color: white;
            padding: 0.7rem 1.8rem;
            cursor: pointer;
            font-size: 1.1rem;
            font-family: 'Garamond', 'Georgia', serif;
            transition: all 0.3s;
            backdrop-filter: blur(5px);
            font-weight: 500;
            letter-spacing: 0.5px;
        }

        .lang-switch button.active {
            background: #c9a961;
            color: #1a4d2e;
            border-color: #c9a961;
            font-weight: 600;
            transform: scale(1.05);
        }

        nav {
            background: linear-gradient(135deg, #00703c 0%, #1a4d2e 100%);
            border-bottom: 4px solid #c9a961;
            border-top: 2px solid #c9a961;
        }

        nav ul {
            list-style: none;
            display: flex;
            justify-content: center;
            flex-wrap: wrap;
            padding: 0;
        }

        nav a {
            display: block;
            padding: 1.2rem 2rem;
            color: white;
            text-decoration: none;
            font-size: 1.15rem;
            transition: all 0.3s;
            font-weight: 500;
        }

        nav a:hover,
        nav a.active {
            background: #c9a961;
            color: #1a4d2e;
            font-weight: 600;
        }

        .lang-content {
            display: none;
            padding: 2.5rem;
            max-width: 1400px;
            margin: 0 auto;
        }

        .lang-content.active {
            display: block;
        }

        .section-title {
            color: #1a4d2e;
            font-size: 2rem;
            font-weight: 400;
            margin: 2rem 0 1.5rem 0;
            padding-bottom: 0.5rem;
            border-bottom: 2px solid #00703c;
        }

        .semester-title {
            color: #00703c;
            font-size: 1.5rem;
            font-weight: 500;
            margin: 2rem 0 1rem 0;
        }

        .seminar-table {
            width: 100%;
            border-collapse: collapse;
            margin: 2rem 0;
            background: white;
        }

        .seminar-table th {
            background: #f5f5f0;
            color: #1a4d2e;
            padding: 1rem;
            text-align: left;
            font-weight: 600;
            border-bottom: 2px solid #00703c;
            font-size: 1rem;
        }

        .seminar-table td {
            padding: 1.5rem 1rem;
            border-bottom: 1px solid #e0e0e0;
            vertical-align: top;
        }

        .seminar-table tr:hover {
            background: #fafaf8;
        }

        .date-time {
            color: #00703c;
            font-weight: 500;
            white-space: nowrap;
            min-width: 150px;
        }

        .speaker-info {
            min-width: 200px;
        }

        .speaker-name {
            color: #1a4d2e;
            font-weight: 600;
            font-size: 1.05rem;
        }

        .speaker-affiliation {
            color: #666;
            font-size: 0.95rem;
            font-style: italic;
            margin-top: 0.3rem;
        }

        .talk-title {
            color: #2c2c2c;
            font-weight: 500;
            font-size: 1.05rem;
            margin-bottom: 0.5rem;
        }

        .talk-abstract {
            color: #555;
            font-size: 0.95rem;
            line-height: 1.6;
            margin-top: 0.5rem;
            text-align: justify;
        }

        .location {
            color: #00703c;
            font-weight: 500;
            white-space: nowrap;
        }

        .expand-btn {
            color: #00703c;
            cursor: pointer;
            font-size: 0.9rem;
            margin-top: 0.5rem;
            display: inline-block;
            text-decoration: underline;
        }

        .expand-btn:hover {
            color: #1a4d2e;
        }

        .abstract-content {
            display: none;
            margin-top: 0.8rem;
        }

        .abstract-content.show {
            display: block;
        }

        footer {
            background: #00703C;
            color: white;
            padding: 2.5rem;
            text-align: center;
            margin-top: 3rem;
        }

        footer a {
            color: #c9a961;
            text-decoration: none;
        }

        footer a:hover {
            text-decoration: underline;
        }

        .no-seminars {
            text-align: center;
            padding: 3rem;
            color: #666;
            font-style: italic;
        }

        @media (max-width: 768px) {
            header h1 {
                font-size: 2rem;
            }

            .seminar-table {
                font-size: 0.9rem;
            }

            .seminar-table th,
            .seminar-table td {
                padding: 0.8rem 0.5rem;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <canvas id="wormholeCanvas"></canvas>
            <div class="university-name">Universit√© de Sherbrooke ¬∑ D√©partement de math√©matiques</div>
            <h1 class="lang-content lang-fr active">S√©minaire Junior en G√©om√©trie et Physique Math√©matique</h1>
            <h1 class="lang-content lang-en">Junior Seminar in Geometry and Mathematical Physics</h1>
            <div class="lang-switch">
                <button class="active" onclick="switchLanguage('fr')" data-lang="fr">Fran√ßais</button>
                <button onclick="switchLanguage('en')" data-lang="en">English</button>
            </div>
        </header>

        <nav class="lang-content lang-fr active">
            <ul>
                <li><a href="index.html">Accueil</a></li>
                <li><a href="upcoming.html">S√©minaires √† venir</a></li>
                <li><a href="past.html" class="active">S√©minaires pass√©s</a></li>
                <li><a href="members.html">Membres du groupe</a></li>
                <li><a href="events.html">√âv√©nements</a></li>
            </ul>
        </nav>

        <nav class="lang-content lang-en">
            <ul>
                <li><a href="index.html">Home</a></li>
                <li><a href="upcoming.html">Upcoming Seminars</a></li>
                <li><a href="past.html" class="active">Past Seminars</a></li>
                <li><a href="members.html">Group Members</a></li>
                <li><a href="events.html">Events</a></li>
            </ul>
        </nav>

        <!-- VERSION FRAN√áAISE -->
        <div class="lang-content lang-fr active">
            <h2 class="section-title">S√©minaires pass√©s</h2>
            
            <!-- Semestre Automne 2024 -->
            <h3 class="semester-title">Automne 2025</h3>
            <table class="seminar-table">
                <thead>
                    <tr>
                        <th>Date / Heure</th>
                        <th>Conf√©rencier</th>
                        <th>Titre</th>
                        <th>Lieu</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td class="date-time">16 octobre 2025<br>12:00-13:00</td>
                        <td class="speaker-info">
                            <div class="speaker-name">Mohamed Moussadek Maiza</div>
                            <div class="speaker-affiliation">Universit√© de Sherbrooke</div>
                        </td>
                        <td>
                            <div class="talk-title">Espaces de d√©formation des espaces quasi-hamiltoniens</div>
                            <span class="expand-btn" onclick="toggleAbstract('abstract-f24-1')">Lire le r√©sum√© ‚ñº</span>
                            <div id="abstract-f24-1" class="abstract-content">
                                <p class="talk-abstract">
                                    La g√©om√©trie symplectique, branche fondamentale de la g√©om√©trie diff√©rentielle, √©tudie les vari√©t√©s diff√©rentiables de dimension paire munies d'une 2-forme ferm√©e non d√©g√©n√©r√©e œâ. Elle est apparue comme une formulation g√©om√©trique de la m√©canique classique, o√π l'espace des phases d'un syst√®me physique admet une riche structure symplectique.
                                    <br><br>
                                    Deux aspects importants de la g√©om√©trie symplectique se sont d√©velopp√©s : les vari√©t√©s hamiltoniennes <em>G</em> et les vari√©t√©s quasi-hamiltoniennes <em>G</em>. Les exemples fondamentaux de vari√©t√©s quasi-hamiltoniennes <em>G</em> sont les classes de conjugaison <em>C</em> dans <em>G</em>, dont les contreparties hamiltoniennes sont les orbites coadjointes dans le dual de l'alg√®bre de Lie <em>ùî§*</em>.
                                    <br><br>
                                    Dans cet expos√©, nous pr√©sentons une th√©orie de la d√©formation des vari√©t√©s quasi-hamiltoniennes <em>G</em> en vari√©t√©s hamiltoniennes <em>G</em> pour tout groupe de Lie compact. Cette th√©orie fournit des d√©formations explicites dans plusieurs cas fondamentaux : la d√©formation du double <em>D(G)=G√óG</em> vers le fibr√© cotangent <em>T*G</em>, la d√©formation d'une classe de conjugaison dans <em>G</em> vers l'orbite coadjointe dans <em>ùî§*</em>, et enfin la d√©formation de l'espace des modules de connexions plates √† valeurs dans <em>ùî§</em> sur une surface orientable lisse de genre <em>k</em> ayant <em>r+1</em> composantes de bord vers <em>T*G<sup>g+r</sup></em>.
                                </p>
                            </div>
                        </td>
                        <td class="location">D3-2035</td>
                    </tr>
                    <tr>
                        <td class="date-time">25 novembre 2025<br>12:00-13:00</td>
                        <td class="speaker-info">
                            <div class="speaker-name">Ablanvi Songo</div>
                            <div class="speaker-affiliation">Universit√© de Sherbrooke</div>
                        </td>
                        <td>
                            <div class="talk-title">Une g√©n√©ralisation du th√©or√®me du point-selle</div>
                            <span class="expand-btn" onclick="toggleAbstract('abstract-f24-2')">Lire le r√©sum√© ‚ñº</span>
                            <div id="abstract-f24-2" class="abstract-content">
                                <p class="talk-abstract">
                                    La th√©orie des points critiques a connu un d√©veloppement consid√©rable √† la suite de la parution de l'article d'Ambrosetti et Rabinowitz en 1973, dans lequel fut introduit le c√©l√®bre th√©or√®me du col de la montagne. Leur √©tude porte sur la recherche de points critiques d'une fonctionnelle de classe C<sup>1</sup>, en utilisant la technique du min-max (ou minimax).
                                    <br><br>
                                    D'autres th√©or√®mes du m√™me type ont vu le jour par la suite, tels que le th√©or√®me du point-selle et le th√©or√®me d'enlacement. Plusieurs probl√®mes elliptiques en th√©orie des EDP peuvent √™tre r√©solus en appliquant ces th√©or√®mes. Cependant, lorsque la fonctionnelle associ√©e au probl√®me est fortement ind√©finie (c'est-√†-dire que sa partie quadratique poss√®de √† la fois une infinit√© de valeurs propres positives et une infinit√© de valeurs propres n√©gatives), comme c'est le cas pour de nombreux probl√®mes en math√©matiques physiques, par exemple l'√©quation de Schr√∂dinger non lin√©aire avec potentiel ind√©fini, ou l'√©quation des ondes non lin√©aire stationnaire, l'utilisation de ces th√©or√®mes devient limit√©e.
                                    <br><br>
                                    Dans la litt√©rature, on peut trouver certains r√©sultats permettant la r√©solution de ce type de probl√®mes. Dans cet expos√©, je pr√©senterai une g√©n√©ralisation du th√©or√®me du point-selle pour les fonctionnelles fortement ind√©finies, que Fabrice Colin et moi avons propos√©e dans [1] (en pr√©publication).
                                    <br><br>
                                    [1] F. Colin, A. Songo, An infinite dimensional saddle point theorem and application.
                                </p>
                            </div>
                        </td>
                        <td class="location">D3-2029</td>
                    </tr>
                </tbody>
            </table>
        </div>

        <!-- VERSION ANGLAISE -->
        <div class="lang-content lang-en">
            <h2 class="section-title">Past Seminars</h2>
            
            <!-- Fall Semester 2024 -->
            <h3 class="semester-title">Fall Semester 2025</h3>
            <table class="seminar-table">
                <thead>
                    <tr>
                        <th>Date / Time</th>
                        <th>Speaker</th>
                        <th>Title</th>
                        <th>Location</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td class="date-time">October 16, 2025<br>12:00-13:00</td>
                        <td class="speaker-info">
                            <div class="speaker-name">Mohamed Moussadek Maiza</div>
                            <div class="speaker-affiliation">Universit√© de Sherbrooke</div>
                        </td>
                        <td>
                            <div class="talk-title">Deformation Spaces of Quasi-Hamiltonian Spaces</div>
                            <span class="expand-btn" onclick="toggleAbstract('abstract-f24-1-en')">Read abstract ‚ñº</span>
                            <div id="abstract-f24-1-en" class="abstract-content">
                                <p class="talk-abstract">
                                    Symplectic geometry, a fundamental branch of differential geometry, studies even-dimensional differentiable manifolds equipped with a closed non-degenerate 2-form œâ. It emerged as a geometric formulation of classical mechanics, where the phase space of a physical system admits a rich symplectic structure.
                                    <br><br>
                                    Two important aspects of symplectic geometry have developed: Hamiltonian <em>G</em>-manifolds and quasi-Hamiltonian <em>G</em>-manifolds. The fundamental examples of quasi-Hamiltonian <em>G</em>-manifolds are conjugacy classes <em>C</em> in <em>G</em>, whose Hamiltonian counterparts are coadjoint orbits in the dual of the Lie algebra <em>ùî§*</em>.
                                    <br><br>
                                    In this talk, we present a deformation theory of quasi-Hamiltonian <em>G</em>-manifolds into Hamiltonian <em>G</em>-manifolds for any compact Lie group. This theory provides explicit deformations in several fundamental cases: the deformation of the double <em>D(G)=G√óG</em> to the cotangent bundle <em>T*G</em>, the deformation of a conjugacy class in <em>G</em> to the coadjoint orbit in <em>ùî§*</em>, and finally the deformation of the moduli space of flat <em>ùî§</em>-valued connections on a smooth orientable surface of genus <em>k</em> with <em>r+1</em> boundary components to <em>T*G<sup>g+r</sup></em>.
                                </p>
                            </div>
                        </td>
                        <td class="location">D3-2035</td>
                    </tr>
                    <tr>
                        <td class="date-time">November 25, 2025<br>12:00-13:00</td>
                        <td class="speaker-info">
                            <div class="speaker-name">Ablanvi Songo</div>
                            <div class="speaker-affiliation">Universit√© de Sherbrooke</div>
                        </td>
                        <td>
                            <div class="talk-title">A Generalization of the Saddle Point Theorem</div>
                            <span class="expand-btn" onclick="toggleAbstract('abstract-f24-2-en')">Read abstract ‚ñº</span>
                            <div id="abstract-f24-2-en" class="abstract-content">
                                <p class="talk-abstract">
                                    Critical point theory has undergone considerable development following the publication of Ambrosetti and Rabinowitz's article in 1973, which introduced the famous mountain pass theorem. Their study focuses on finding critical points of a C<sup>1</sup> functional using the min-max (or minimax) technique.
                                    <br><br>
                                    Other theorems of the same type have subsequently emerged, such as the saddle point theorem and the linking theorem. Several elliptic problems in PDE theory can be solved by applying these theorems. However, when the functional associated with the problem is strongly indefinite (meaning its quadratic part possesses both infinitely many positive eigenvalues and infinitely many negative eigenvalues), as is the case for many problems in mathematical physics‚Äîfor example, the nonlinear Schr√∂dinger equation with indefinite potential, or the stationary nonlinear wave equation‚Äîthe use of these theorems becomes limited.
                                    <br><br>
                                    In the literature, certain results can be found that allow the resolution of this type of problem. In this talk, I will present a generalization of the saddle point theorem for strongly indefinite functionals, which Fabrice Colin and I have proposed in [1] (preprint).
                                    <br><br>
                                    [1] F. Colin, A. Songo, An infinite dimensional saddle point theorem and application.
                                </p>
                            </div>
                        </td>
                        <td class="location">D3-2029</td>
                    </tr>
                </tbody>
            </table>
        </div>
            
        <footer>
            <p>&copy; 2025 <a href="https://www.usherbrooke.ca/" style="color: white;">Universit√© de Sherbrooke</a> - <a href="https://www.usherbrooke.ca/mathematiques/" style="color: white;">D√©partement de math√©matiques</a></p>
            <p>Contact: <a href="mailto:junior-seminar.gmp@outlook.com" style="color: white;">junior-seminar.gmp@outlook.com</a></p>
        </footer>
    </div>

    <script>
        const canvas = document.getElementById('wormholeCanvas');
        const ctx = canvas.getContext('2d');
        
        canvas.width = canvas.offsetWidth;
        canvas.height = canvas.offsetHeight;
        
        window.addEventListener('resize', () => {
            canvas.width = canvas.offsetWidth;
            canvas.height = canvas.offsetHeight;
        });

        let time = 0;
        const centerX = canvas.width / 2;
        const centerY = canvas.height / 2;

        class Wormhole {
            constructor() {
                this.rings = [];
                this.numRings = 40;
                this.maxRadius = Math.max(canvas.width, canvas.height);
                
                for (let i = 0; i < this.numRings; i++) {
                    this.rings.push({
                        z: i * 30,
                        rotation: Math.random() * Math.PI * 2
                    });
                }
            }

            draw(t) {
                const bgGradient = ctx.createRadialGradient(
                    canvas.width / 2, canvas.height / 2, 0,
                    canvas.width / 2, canvas.height / 2, this.maxRadius
                );
                bgGradient.addColorStop(0, 'rgba(20, 10, 30, 0.3)');
                bgGradient.addColorStop(0.5, 'rgba(40, 20, 60, 0.2)');
                bgGradient.addColorStop(1, 'rgba(0, 0, 0, 0.4)');
                ctx.fillStyle = bgGradient;
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                this.rings.forEach((ring, index) => {
                    ring.z -= 2;
                    if (ring.z < -100) {
                        ring.z = this.numRings * 30;
                        ring.rotation = Math.random() * Math.PI * 2;
                    }

                    const perspective = 800 / (800 + ring.z);
                    const radius = Math.abs(ring.z * 2) * perspective;
                    const alpha = Math.max(0, 1 - Math.abs(ring.z) / 800);
                    
                    const colorProgress = (ring.z + 100) / 1000;
                    let r, g, b;
                    
                    if (colorProgress < 0.3) {
                        r = 138 + (255 - 138) * (colorProgress / 0.3);
                        g = 43 + (255 - 43) * (colorProgress / 0.3);
                        b = 226;
                    } else if (colorProgress < 0.7) {
                        r = 255;
                        g = 255 - (255 - 100) * ((colorProgress - 0.3) / 0.4);
                        b = 226 - (226 - 150) * ((colorProgress - 0.3) / 0.4);
                    } else {
                        r = 255;
                        g = 100 + (150 - 100) * ((colorProgress - 0.7) / 0.3);
                        b = 150 - (150 - 50) * ((colorProgress - 0.7) / 0.3);
                    }

                    const segments = 32;
                    for (let i = 0; i < segments; i++) {
                        const angle1 = (i / segments) * Math.PI * 2 + ring.rotation;
                        const angle2 = ((i + 1) / segments) * Math.PI * 2 + ring.rotation;
                        
                        const x1 = centerX + Math.cos(angle1) * radius;
                        const y1 = centerY + Math.sin(angle1) * radius * 0.6;
                        const x2 = centerX + Math.cos(angle2) * radius;
                        const y2 = centerY + Math.sin(angle2) * radius * 0.6;

                        ctx.strokeStyle = `rgba(${r}, ${g}, ${b}, ${alpha * 0.6})`;
                        ctx.lineWidth = 2 * perspective;
                        ctx.beginPath();
                        ctx.moveTo(x1, y1);
                        ctx.lineTo(x2, y2);
                        ctx.stroke();
                    }

                    const radialLines = 16;
                    for (let i = 0; i < radialLines; i++) {
                        const angle = (i / radialLines) * Math.PI * 2 + ring.rotation;
                        const x = centerX + Math.cos(angle) * radius;
                        const y = centerY + Math.sin(angle) * radius * 0.6;

                        ctx.strokeStyle = `rgba(${r}, ${g}, ${b}, ${alpha * 0.4})`;
                        ctx.lineWidth = 1.5 * perspective;
                        ctx.beginPath();
                        ctx.moveTo(centerX, centerY);
                        ctx.lineTo(x, y);
                        ctx.stroke();
                    }
                });

                const centralGlow = ctx.createRadialGradient(
                    centerX, centerY, 0,
                    centerX, centerY, 80
                );
                centralGlow.addColorStop(0, 'rgba(255, 200, 100, 0.8)');
                centralGlow.addColorStop(0.3, 'rgba(255, 150, 80, 0.5)');
                centralGlow.addColorStop(0.6, 'rgba(138, 43, 226, 0.3)');
                centralGlow.addColorStop(1, 'rgba(0, 0, 0, 0)');
                
                ctx.fillStyle = centralGlow;
                ctx.fillRect(centerX - 80, centerY - 80, 160, 160);

                for (let i = 0; i < 50; i++) {
                    const particleAngle = (i / 50) * Math.PI * 2 + t * 0.001;
                    const particleRadius = 100 + Math.sin(t * 0.002 + i) * 50;
                    const px = centerX + Math.cos(particleAngle) * particleRadius;
                    const py = centerY + Math.sin(particleAngle) * particleRadius * 0.6;
                    
                    ctx.fillStyle = `rgba(255, 200, 150, ${0.3 + Math.sin(t * 0.01 + i) * 0.3})`;
                    ctx.beginPath();
                    ctx.arc(px, py, 2, 0, Math.PI * 2);
                    ctx.fill();
                }
            }
        }

        class SphereField {
            constructor() {
                this.spheres = [];
                for (let i = 0; i < 8; i++) {
                    this.spheres.push({
                        x: Math.random() * canvas.width,
                        y: Math.random() * canvas.height,
                        radius: 15 + Math.random() * 25,
                        speedX: (Math.random() - 0.5) * 0.5,
                        speedY: (Math.random() - 0.5) * 0.5,
                        rotation: Math.random() * Math.PI * 2,
                        rotSpeed: 0.01 + Math.random() * 0.02
                    });
                }
            }

            draw(t) {
                this.spheres.forEach(sphere => {
                    sphere.x += sphere.speedX;
                    sphere.y += sphere.speedY;
                    sphere.rotation += sphere.rotSpeed;

                    if (sphere.x < 0 || sphere.x > canvas.width) sphere.speedX *= -1;
                    if (sphere.y < 0 || sphere.y > canvas.height) sphere.speedY *= -1;

                    ctx.save();
                    ctx.translate(sphere.x, sphere.y);
                    ctx.rotate(sphere.rotation);

                    for (let i = 0; i < 8; i++) {
                        const angle = (i / 8) * Math.PI * 2;
                        ctx.strokeStyle = 'rgba(255, 215, 0, 0.4)';
                        ctx.lineWidth = 1.5;
                        ctx.beginPath();
                        
                        for (let phi = 0; phi <= Math.PI; phi += 0.15) {
                            const x = sphere.radius * Math.sin(phi) * Math.cos(angle);
                            const y = sphere.radius * Math.sin(phi) * Math.sin(angle) * 0.5;
                            const z = sphere.radius * Math.cos(phi);
                            
                            if (phi === 0) ctx.moveTo(x, y - z * 0.3);
                            else ctx.lineTo(x, y - z * 0.3);
                        }
                        ctx.stroke();
                    }

                    const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, sphere.radius);
                    gradient.addColorStop(0, 'rgba(255, 215, 0, 0.3)');
                    gradient.addColorStop(0.7, 'rgba(255, 150, 100, 0.2)');
                    gradient.addColorStop(1, 'rgba(0, 0, 0, 0)');
                    ctx.fillStyle = gradient;
                    ctx.beginPath();
                    ctx.arc(0, 0, sphere.radius, 0, Math.PI * 2);
                    ctx.fill();

                    ctx.restore();
                });
            }
        }

        class KleinBottle {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.rotation = 0;
                this.scale = 40;
            }

            draw(t) {
                this.rotation += 0.01;
                ctx.save();
                ctx.translate(this.x, this.y);

                const points = [];
                const uSteps = 30;
                const vSteps = 20;

                for (let i = 0; i <= uSteps; i++) {
                    const u = (i / uSteps) * Math.PI * 2;
                    for (let j = 0; j <= vSteps; j++) {
                        const v = (j / vSteps) * Math.PI * 2;
                        
                        const r = 4 * (1 - Math.cos(u) / 2);
                        const x = 6 * Math.cos(u) * (1 + Math.sin(u)) + r * Math.cos(v + Math.PI);
                        const y = 16 * Math.sin(u);
                        const z = r * Math.sin(v);

                        const rotX = x * Math.cos(this.rotation) - z * Math.sin(this.rotation);
                        const rotZ = x * Math.sin(this.rotation) + z * Math.cos(this.rotation);
                        
                        const depth = rotZ;
                        const screenX = rotX * (this.scale / 20);
                        const screenY = y * (this.scale / 20) * 0.7;
                        
                        points.push({ x: screenX, y: screenY, depth });
                    }
                }

                points.sort((a, b) => a.depth - b.depth);
                
                points.forEach((point, i) => {
                    const opacity = 0.2 + (point.depth + 10) / 30 * 0.5;
                    ctx.fillStyle = `rgba(150, 100, 255, ${opacity})`;
                    ctx.beginPath();
                    ctx.arc(point.x, point.y, 2, 0, Math.PI * 2);
                    ctx.fill();
                });

                ctx.restore();
            }
        }

        class FundamentalGroup {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.loops = [];
                this.baseRadius = 30;
                
                for (let i = 0; i < 5; i++) {
                    this.loops.push({
                        angle: (i / 5) * Math.PI * 2,
                        phase: Math.random() * Math.PI * 2,
                        speed: 0.02 + Math.random() * 0.02,
                        radius: 20 + i * 8
                    });
                }
            }

            draw(t) {
                ctx.save();
                ctx.translate(this.x, this.y);

                ctx.fillStyle = 'rgba(255, 100, 100, 0.8)';
                ctx.beginPath();
                ctx.arc(0, 0, 5, 0, Math.PI * 2);
                ctx.fill();

                this.loops.forEach((loop, index) => {
                    loop.phase += loop.speed;
                    
                    const numPoints = 60;
                    ctx.strokeStyle = `rgba(100, 255, 150, ${0.4 + index * 0.1})`;
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    
                    for (let i = 0; i <= numPoints; i++) {
                        const t = (i / numPoints) * Math.PI * 2;
                        const r = loop.radius * (1 + 0.3 * Math.sin(3 * t + loop.phase));
                        const x = r * Math.cos(t + loop.angle);
                        const y = r * Math.sin(t + loop.angle) * 0.7;
                        
                        if (i === 0) ctx.moveTo(x, y);
                        else ctx.lineTo(x, y);
                    }
                    ctx.closePath();
                    ctx.stroke();

                    for (let i = 0; i < 8; i++) {
                        const t = (i / 8) * Math.PI * 2;
                        const r = loop.radius * (1 + 0.3 * Math.sin(3 * t + loop.phase));
                        const x = r * Math.cos(t + loop.angle);
                        const y = r * Math.sin(t + loop.angle) * 0.7;
                        
                        ctx.fillStyle = 'rgba(100, 255, 150, 0.6)';
                        ctx.beginPath();
                        ctx.arc(x, y, 2, 0, Math.PI * 2);
                        ctx.fill();
                    }
                });

                ctx.restore();
            }
        }

        class CalabiYau {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.rotation = 0;
                this.points = [];
                this.initPoints();
            }

            initPoints() {
                for (let i = 0; i < 100; i++) {
                    const theta = Math.random() * Math.PI * 2;
                    const phi = Math.acos(2 * Math.random() - 1);
                    const r = 40 + Math.random() * 15;
                    this.points.push({ theta, phi, r, speed: 0.01 + Math.random() * 0.01 });
                }
            }

            draw(t) {
                this.rotation += 0.008;
                ctx.save();
                ctx.translate(this.x, this.y);

                this.points.forEach(p => {
                    p.theta += p.speed;
                    
                    const modulation = 1 + 0.2 * Math.sin(4 * p.theta) * Math.cos(3 * p.phi);
                    const r = p.r * modulation;
                    
                    const x = r * Math.sin(p.phi) * Math.cos(p.theta + this.rotation);
                    const y = r * Math.sin(p.phi) * Math.sin(p.theta + this.rotation) * 0.6;
                    const z = r * Math.cos(p.phi);
                    
                    const depth = z;
                    const opacity = 0.3 + (depth + 50) / 100 * 0.4;
                    
                    ctx.fillStyle = `rgba(200, 100, 255, ${opacity})`;
                    ctx.beginPath();
                    ctx.arc(x, y - z * 0.2, 2, 0, Math.PI * 2);
                    ctx.fill();

                    if (Math.random() > 0.98) {
                        ctx.strokeStyle = `rgba(200, 100, 255, ${opacity * 0.5})`;
                        ctx.lineWidth = 1;
                        ctx.beginPath();
                        ctx.moveTo(0, 0);
                        ctx.lineTo(x, y - z * 0.2);
                        ctx.stroke();
                    }
                });

                ctx.restore();
            }
        }

        const wormhole = new Wormhole();
        const sphereField = new SphereField();
        const kleinBottle = new KleinBottle(canvas.width * 0.2, canvas.height * 0.25);
        const fundamentalGroup = new FundamentalGroup(canvas.width * 0.8, canvas.height * 0.3);
        const calabiYau = new CalabiYau(canvas.width * 0.5, canvas.height * 0.75);

        function animate() {
            wormhole.draw(time);
            sphereField.draw(time);
            kleinBottle.draw(time);
            fundamentalGroup.draw(time);
            calabiYau.draw(time);
            
            time++;
            requestAnimationFrame(animate);
        }

        window.addEventListener('resize', () => {
            kleinBottle.x = canvas.width * 0.2;
            kleinBottle.y = canvas.height * 0.25;
            fundamentalGroup.x = canvas.width * 0.8;
            fundamentalGroup.y = canvas.height * 0.3;
            calabiYau.x = canvas.width * 0.5;
            calabiYau.y = canvas.height * 0.75;
        });

        animate();

        function switchLanguage(lang) {
            document.querySelectorAll('.lang-content').forEach(el => el.classList.remove('active'));
            document.querySelectorAll('.lang-' + lang).forEach(el => el.classList.add('active'));
            document.querySelectorAll('.lang-switch button').forEach(btn => btn.classList.remove('active'));
            document.querySelector('.lang-switch button[data-lang="' + lang + '"]').classList.add('active');
        }

        function toggleAbstract(id) {
            const element = document.getElementById(id);
            const btn = element.previousElementSibling;
            
            if (element.classList.contains('show')) {
                element.classList.remove('show');
                btn.innerHTML = btn.innerHTML.replace('‚ñ≤', '‚ñº').replace('Hide', 'Read').replace('Masquer', 'Lire');
            } else {
                element.classList.add('show');
                btn.innerHTML = btn.innerHTML.replace('‚ñº', '‚ñ≤').replace('Read', 'Hide').replace('Lire', 'Masquer');
            }
        }
    </script>
</body>
</html>
